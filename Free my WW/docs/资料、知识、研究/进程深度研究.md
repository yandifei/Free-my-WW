# <center>进程学习</center>
本来在研究python的pustil的库，但是看到进程的参数就懵逼了，之前都有对进程有过使用和了解，但是这个库的进程函数给的参数似乎还需要更进一步的了解。
***之前的知识：***
1. 进程创建
2. 父进程
3. 子进程
4. 进程的属性（PID、创建的时间、状态、消耗的只有）
5. 进程间的通讯（队列、栈）

直接去王道考研那里补这部分的知识[王道计算机考研 操作系统](https://www.bilibili.com/video/BV1YE411D7nH?p=13&vd_source=298465310cd98e6ceddf1afe7d72e7ec)
# 进程和程序的关系
把代码文件（如C的代码文件即.c文件）经过编译器编译后编程二进制文件（.exe），这个exe文件编译后首先是在硬盘里面，运行前需要把程序放入内存。双击exe程序后在内存需要创建对应的进程，也就要创建相应的PCB，程序段--包
含程序指令，数据段--包含运行过程中产生的各种数据。
一个进程实体(进程映像)由PCB、程序段、数据段组成。
进程是动态的，进程实体(进程映像)是静态的。
程序段、数据段、PCB三部分组成了进程实体(进程映像)。引入进程实体的概念后，可把进程定义为:***进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。***
# 什么是进程
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
# 进程的组成
1. PCB是进程存在的唯一标志
   1. 进程描述信息
   2. 进程控制和管理信息
   3. 资源分配清单
   4. 处理机相关信息
1. 程序段
   1. 程序的代码(指令序列)
2. 数据段
   1. 运行过程中产生的各种数据(如:程序中定义的变量)
# 进程的状态与转换
## 进程状态
1. 进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB
2. 当进程创建完成后，便进入“就绪态”处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行
3. 如果一个进程此时在CPU上运行，那么这个进程处于“运行态”CPU会执行该进程对应的程序(执行指令序列)
4. 在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应)在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态
5. 一个进程可以执行exit系统调用，请求操作系统终止该进程此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。


### 基本状态（）
***进程的整个生命周期中，大部分时间都处于这三种状态***
单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态
1. 运行态(Running)占有CPU，并在CPU上运行
2. 就绪态(Ready)已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
3. 阻塞态(Waiting/Blocked，又称:等待态)等待某一事件而暂时不能运行
### 另外两种状态
1. 创建态(New，又称:新建态)进程正在被创建，操作系统为进程分配资源、初始化PCB
2. 终止态(Terminated，又称:结束态)进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

## 进程状态间的转换
就绪态->运行态：进程被调度
运行态->就绪态:时间片到，或CPU被其他高优先级的进程抢占
运行态->阻塞态:等待系统资源分配，或等待某事件发生(主动行为)
阻塞态->就绪态:资源分配到位，等待的事件发生(被动行为)
创建态->就绪态:系统完成创建进程相关的工作
运行态->终止态:进程运行结束，或运行过程中遇到不可修复的错误
# 进程的终止
## 撤销原语
1. 从PCB集合中找到终止进程的PCB
2. 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
3. 终止其所有子进程。
4. 将该进程拥有的所有资源归还给父进程或操作系统
5. 删除PCB
## 引起进程终止的事件
正常结束
异常结束
外界干预
# 进程的阻塞和唤醒
阻塞原语唤醒原语必须成对使用阻塞原语
## 进程的阻塞
1. 找到要阻塞的进程对应的PCB
2. 保护进程运行现场，将PCB状态信息设置为“阻塞态"，暂时停止进程运行
3. 将PCB插入相应事件的等待队列

引起进程阻塞的事件
1. 需要等待系统分配某种资源
2. 需要等待相互合作的其他进程完成工作

## 进程的唤醒
1. 唤醒原语
   1. 在事件等待队列中找到PCB
   2. 将PCB从等待队列移除，设置进程为就绪态
   3. 将PCB插入就绪队列，等待被调度
2. 引起进程唤醒的事件:等待的事件发生,因何事阻塞，就应由何事唤醒

# 进程通讯
1. 共享存储
   1. 设置一个共享内存区域，并映射到进程的虚拟地址空
   2. 要互斥地访问共享空间（由通信进程自己负责实现互）
   3. 两种方式
      1. 基于数据结构(低级)
      2. 基于存储区的共享(高级)
1. 消息传递
   1. 传递结构化的消息(消息头/消息体)
   2. 系统提供“发送/接受原语”
   3. 两种方式
      1. 直接通信方式：消息直接挂到接收进程的消息队列里
      2. 间接(信箱)通信方式：消息先发到中间体（信箱）
2. 管道通信
   1. 设置一个特殊的共享文件(管道)，其实就是一个内存缓冲区
   2. 一个管道只能实现半双工通信
   3. 实现双向同时通信要建立两个管道
   4. 各进程要互斥访问管道(由操作系统负责实现互斥)
   5. 管道写满时，写进程阻塞。管道读空时，读进程阻塞
***
# 进程终止问题（ 父进程被终止后，子进程能否继续运行？）
默认行为：
当父进程被终止（如使用 psutil 的 kill()），其子进程不会自动终止，而是会成为孤儿进程（Orphan Process）。
Unix/Linux：孤儿进程会被 init 进程（PID=1）接管，继续运行。
Windows：孤儿进程可能由系统进程（如 services.exe）接管，行为与 Unix 类似。
例外情况：
如果父进程在终止前显式终止子进程（如调用 subprocess 的 terminate()），子进程会被终止。
## 子进程与父进程的关系
父子关系：
子进程的创建者是其父进程，子进程的 ppid（Parent PID）指向父进程的 PID。
生命周期独立性
父进程和子进程的生命周期是独立的。父进程终止后，子进程可以继续运行（除非显式终止）。
***
# 孤儿进程和僵尸进程 
在操作系统中，孤儿进程（Orphan Process） 和 僵尸进程（Zombie Process） 是两种特殊的进程状态，它们的产生和影响不同。
## 孤儿进程（Orphan Process）
1. 定义
当父进程先于子进程终止时，子进程会被操作系统重新分配给一个特定的“父进程”（如 init 或 systemd），这种失去原父进程的子进程称为孤儿进程。
2. 产生原因
父进程意外崩溃或被强制终止。
父进程主动退出但未等待子进程结束
3. 操作系统行为
Linux/Unix：由 init 进程（PID=1）接管孤儿进程，并负责后续的资源回收。
Windows：由系统进程（如 services.exe）接管。
4. 特点
无害：孤儿进程仍在运行，且会被系统接管，避免资源泄漏。
生命周期：由新父进程管理，最终正常终止。
## 僵尸进程（Zombie Process）
1. 定义
当子进程已终止，但父进程未调用 wait() 或 waitpid() 获取其退出状态时，子进程的进程描述符（PID、退出码等）会残留在系统中，成为僵尸进程。
2. 产生原因
父进程未正确处理子进程的终止状态（如未调用 wait()）。
父进程设计缺陷或逻辑错误。
3. 特点
无害但需警惕：僵尸进程本身不占用内存或 CPU，但占用 PID 资源。
4. 风险：如果大量僵尸进程累积，可能导致 PID 耗尽，无法创建新进程。


僵尸进程大量累积是否会导致 PID 耗尽？系统如何处理？
PID 耗尽的可能性
PID 范围：Linux 默认 PID 上限为 32768（可通过 /proc/sys/kernel/pid_max 调整），Windows 默认为 65536。
僵尸进程占用 PID：每个僵尸进程会占用一个 PID，若达到上限，新进程无法创建。
系统的处理机制
PID 回收延迟：
系统会优先复用已释放的 PID，僵尸进程的 PID 在其父进程调用 wait() 后才会释放。
若父进程长期不回收，PID 可能耗尽。
内核保护机制：
Linux：当 PID 接近上限时，系统可能拒绝新进程（返回 -EAGAIN 错误）。
Windows：系统会强制终止部分进程或阻止新进程创建。
是否蓝屏
Linux：不会蓝屏，但可能导致关键服务（如 SSH）无法启动。
Windows：PID 耗尽通常不会直接导致蓝屏，但可能触发系统不稳定或应用程序崩溃。
### 总结
孤儿进程 vs. 僵尸进程
| 特征 | 孤儿进程 | 僵尸进程 |
| - | - | - |
| 进程状态 | 仍在运行 | 已终止 |
| 父进程状态 | 父进程已终止 | 父进程仍在运行但未调用 wait() |
| 资源占用 |占用内存和 CPU	| 不占用内存/CPU，但占用 PID |
| 操作系统处理 | 由 init 接管并回收资源 | 需父进程主动回收 |
| 危害性 | 无害 | 大量累积可能导致 PID 耗尽 |
***
# windows进程控制（python）
win32process.GetWindowThreadProcessId(hwnd) 是 Windows API 的封装，用于通过窗口句柄（HWND）获取与该窗口关联的线程 ID和进程 PID。它的返回值是一个元组
## 1. 进程 PID 的归属
进程 PID 是创建该窗口的进程的标识符。
主进程：如果窗口由主进程直接创建（例如，记事本的主窗口），则 PID 对应主进程的 ID。
子进程：如果窗口由子进程创建（例如，浏览器中每个标签页可能是一个独立进程），则 PID 对应子进程的 ID。
关键点：Windows 中每个进程有唯一的 PID，无论主进程还是子进程。如果窗口是子进程创建的，PID 就是子进程的 PID，而不是父进程的。
## 2. 线程 ID 的归属
线程 ID 是创建并管理该窗口的线程的标识符。
主线程：如果窗口由主线程创建（常见于单线程应用程序），则线程 ID 是主线程的 ID。
子线程：如果窗口由子线程创建（例如，后台线程负责创建窗口），则线程 ID 是子线程的 ID。
关键点：一个进程可以包含多个线程，窗口通常由某个线程的消息循环驱动。
## Python 中创建的进程是否都是子进程？
是的：
Python 中通过以下方式创建的进程均为当前进程的子进程：
multiprocessing.Process()
subprocess.Popen()
os.fork()（仅 Unix）


















